[{"title":"Dubbo性能调优","url":"/2018/09/13/dubbo-performance/","content":"\n## 性能优化\n### dubbo序列化+netty\n目前客户端数据接口的场景99%为1k数据量以内，根据各种协议性能测试对比分析，选用dubbo序列化与netty传输方式可达到性能最大化，以下为阿里官方给出的性能测试结果，提供参考：\n\n1k string 场景：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/Dubbo-1k.png)\n\n<!--more-->\n\n### netty线程池配置\n经过线上生产环境压力测试（服务器48核，由于CPU为AMD，单核处理能力偏低），评估后最优线程数配置为500，采用固定大小的线程池，计算密集型服务可最大分配8核，IO密集型服务最大分配4核。\n\n线上2016年1月31日系统无法接入请求故障维持4个多小时，排查后发现后端BOSS系统处理能力有限，且响应时间过长，导致线程满负荷状态下切配置队列的情况下，线程池打满后，请求全部进入队列排队，请求与处理能力严重失衡，导致队列很快也被打满，所有请求无法接入，服务呈现不可用状态，再经过分析后，决定去掉队列且将连接超时时间由12秒缩短为5秒，舍弃BOSS系统响应超过5秒的请求，对用户侧进行友好提示，保证BOSS响应低于5秒的用户可正常使用。\n\n配置策略：\n```xml\n<dubbo:protocol name=\"dubbo\" port=\"${dubbo.protocol.port}\" server=\"netty\" client=\"netty\" serialization=\"dubbo\" charset=\"UTF-8\" threadpool=\"fixed\" threads=\"500\" queues=\"0\" buffer=\"8192\" accepts=\"0\" payload=\"8388608\" />\n```\n\n### zookeeper注册中心\n支持基于网络的集群方式，适合生产环境服务数量较多环境下使用，且配置使用方式简单，可靠性高。\n```xml\n<dubbo:registry protocol=\"zookeeper\" address=\"${dubbo.registry.address}\" file=\"${user.home}/.dubbo/${dubbo.registry.file}\"/>\n```\n**特别注意：** zookeeper采用集群方式保证注册中心服务的高可用与高性能，部署节点数应为奇数。\n\n### JVM配置优化\n\n1. 方案一：通用方式\n```\n#JAVA_HOME=/application/search/vertical-search/vertical-search/jdk1.7.0_51\nVERTICAL_SEARCH_LOG=\"/data/gclog/\"\n#VERTICAL_SEARCH_CONF=\"/application/search/vertical-search/conf\"\n\nJAVA_OPTS='-server -verbose:gc -Xms6000m -Xmx6000m -Xmn2000m -XX:PermSize=300m -XX:MaxPermSize=300m -Xss256k -XX:NewSize=500m -XX:MaxNewSize=500m -XX:+UseConcMarkSweepGC -XX:ParallelGCThreads=16 -XX:+UseCMSCompactAtFullCollection -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+UseParNewGC -XX:+DisableExplicitGC -Xloggc:${VERTICAL_SEARCH_LOG}/logs/gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${VERTICAL_SEARCH_LOG}/logs/HeapDumpOnOutOfMemoryError.log -XX:+DisableExplicitGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -DVERTICAL_SEARCH_LOG=${VERTICAL_SEARCH_LOG}'\n```\n\n2. 方案二：又有改进了，上面方法不太好，因为没有用到救助空间，所以年老代容易满，CMS执行会比较频繁。我改善了一下，还是用救助空间，但是把救助空间加大，这样也不会有promotion failed。具体操作上，32位Linux和64位Linux好像不一样，64位系统似乎只要配置MaxTenuringThreshold参数，CMS还是有暂停。为了解决暂停问题和promotion failed问题，最后我设置-XX:SurvivorRatio=1 ，并把MaxTenuringThreshold去掉，这样即没有暂停又不会有promotoin failed，而且更重要的是，年老代和永久代上升非常慢（因为好多对象到不了年老代就被回收了），所以CMS执行频率非常低，好几个小时才执行一次，这样，服务器都不用重启了。\n```\n#JAVA_HOME=/application/search/vertical-search/vertical-search/jdk1.7.0_51\nVERTICAL_SEARCH_LOG=\"/data/gc\"\n\nJAVA_OPTS='-server -Xmx4000M -Xms4000M -Xmn600M -XX:PermSize=500M -XX:MaxPermSize=500M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:${VERTICAL_SEARCH_LOG}/logs/gc.log'\n```\n\n3. 方案三：64位jdk参考设置，年老代涨得很慢，CMS执行频率变小，CMS没有停滞，也不会有promotion failed问题，内存回收得很干净.\n```\n#JAVA_HOME=/application/search/vertical-search/vertical-search/jdk1.7.0_51\nVERTICAL_SEARCH_LOG=\"/data/gc\"\n\nJAVA_OPTS='-server -Xmx4000M -Xms4000M -Xmn600M -XX:PermSize=500M -XX:MaxPermSize=500M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:${VERTICAL_SEARCH_LOG}/logs/gc.log'\n```\n\n4. 方案四：docker tomcat jvm优化方案:\n```\n-Xmx2048M -Xms2048M -Xmn512M -XX:PermSize=320M -XX:MaxPermSize=320M -Xss256K -XX:+DisableExplicitGC -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:LargePageSizeInBytes=128M -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC\n```\n\n\n***Never Give Up!***\n\n","tags":["architecture"]},{"title":"分布式事务","url":"/2018/09/13/distributed-transaction/","content":"\n> 分布式事务场景如何设计系统架构及解决数据一致性问题，个人理解最终方案把握以下原则就可以了，那就是：大事务=小事务（原子事务）+异步（消息通知），解决分布式事务的最好办法其实就是不考虑分布式事务，将一个大的业务进行拆分，整个大的业务流程，转化成若干个小的业务流程，然后通过设计补偿流程从而考虑最终一致性。\n\n<!--more-->\n\n### What's 事务\n\n事务（Transaction）及其ACID属性\n\n事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性：\n\n1. 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。\n2. 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。\n3. 隔离性（Isoation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。\n4. 持久性（Durabe）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。\n\n***典型场景：银行转账业务***\n\n例如：李雷账户中有500块钱，韩梅梅账户有200块钱，李雷要从自己的账户中转100块钱给韩梅梅，转账（事务）成功执行完成后应该是李雷账户减100变为400，韩梅梅账户加100变为300，不能出现其他情况，即在事务开始和结束时数据都必须保持一致状态（一致性），事务结束时所有的数据及结构都必须是正确的。并且同样的转账操作（同一流水，即一次转账操作）无论执行多少次结果都相同（幂等性）。\n\n***电商场景：流量充值业务***\n\n再说我们做的一个项目：中国移动-流量充值能力中心，核心业务流程为：\n\n1. 用户进入流量充值商品购买页面，选择流量商品；\n2. 购买流量充值商品，有库存限制则判断库存，生成流量购买订单；\n3. 选择对应的支付方式（和包、银联、支付宝、微信）进行支付操作；\n4. 支付成功后，近实时流量到账即可使用流量商品；\n\n此业务流程看似不是很复杂对吧，不涉及到类似电商业务的实物购买，但是我认为其中的区别并不是很大，只是缺少电商中的物流发货流程，其他流程几乎是一样的，也有库存以及优惠折扣等业务存在。\n\n整个系统交互如下图：\n\n![流量中心系统交互图](http://7xtkrj.com1.z0.glb.clouddn.com/%E6%B5%81%E9%87%8F%E4%B8%AD%E5%BF%83%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png)\n\n\n### 分布式事务\n\n上述两个场景的业务需求已经说完了，接着谈谈分布式事务，要说分布式事务那就先聊聊本地事务与分布式事务：\n\n***Ps***：相同点：首先都是要保证数据正确（即ACID），本地事务与分布式事务还可以对应为：**刚性事务与柔性事务**，在我个人理解刚性事务与柔性事务的最大区别就是：一个完整的事务操作是否可以在**同一物理介质**（例如：内存）上同时完成；柔性事务就是一个完整事务需要**跨物理介质或跨物理节点**（网络通讯），那么排它锁、共享锁等等就没有用武之地了（这里并不是指大事务拆小事务【本地事务】后），无法保证**原子性（Atomicity**）完成事务。个人理解分布式（柔性）事务本质意义上就是-伪事务，柔性事务其实就是根据不同的业务场景使用不同的方法实现最终一致性，因为可以根据业务的特性做部分取舍，在业务过程中可以容忍一定时间内的数据不一致。\n\n在知乎上面看过一篇文章，支付宝的柔性事务实现方式有四种分别针对不同的业务场景，如下图：\n\n![柔性事务-转自知乎作者：梁川](http://7xtkrj.com1.z0.glb.clouddn.com/柔性事务.jpg)\n\n1. 两阶段型\n2. 补偿型\n3. 异步确保型\n4. 最大努力通知型\n\n回到我们流量交易中心的业务场景：\n\n通过Dubbo实现了微服务化，大致拆分如下：\n\n1. 商品服务\n2. 订单服务\n3. 库存服务\n4. 支付服务\n5. 直充服务\n6. 消息服务\n7. 等其他服务\n\n#### 场景一：\n\n库存数量与订单数量一致性，采用补偿型+最大努力通知型，采用原因为不涉及跨机房和长事务（正常情况下库存与订单服务处理很快）：\n1. 用户下单先减库存，库存减成功后；\n2. 调用下单服务：\n3. 2-1. 下单成功，两事务均提交完成；\n4. 2-2. 下单失败，库存回滚，两事务均失败，此处还有一个保障机制（最大努力通知型），就是如果调用库存服务异常，确定库存回滚失败了，则放入消息服务（延时消息队列）分阶段定时重试，努力重试保证库存服务正常后成功回滚。\n\n#### 场景二：\n\n订单信息、支付信息、充值信息三者之间的一致性，采用异步确保型的原因是，整个业务链路太长且跨不同的机房系统，网络延迟较高，业务方面恰好不需要非常高的实时性，所以采用**小事务+异步通知**，目前正常情况下用户从下单到完成支付到流量到账平均为1-5分钟左右：\n\n1. 下单成功即订单服务创建订单成功并发送支付请求到支付网关系统（订单状态-待支付，超过1小时未支付则流转为超时未付撤销，此处用到了RocketMQ的延时消费恰好实现定时器业务场景）。\n2. 返回支付页面，用户在支付交易系统完成支付业务流程，支付网关异步通知流量中心，流量中心接收到支付成功状态后修改订单状态-支付成功，并给支付网关返回成功结果（此处并发压力目前不大，暂时没有再进行异步解耦）。\n3. 流量中心修改完订单状态后，调用消息服务将直充业务放入消息队列，对直充业务进行解耦（原因是直充需要调用31省移动CRM系统，此链路过长，且部分省CRM系统耗时非常大，每个省的处理能力不同，经常出现20秒以上的超时，因此要考虑部分超时较高的省份拖垮系统，进行业务的削峰填谷）；\n4. 3-1. 当直充成功时，修改订单状态-已完成；\n5. 3-2. 当直充失败时（移动特性，例如：直充时正好用户销户或者停机了），修改订单状态为待退款，并调用支付网关系统的退款接口，退款成功后支付网关异步通知流量中心，流量中心修改订单状态为-退款成功；\n6. 3-3. 当直充超时时，调用定时任务服务进行超时重试机制（第一次重试在10分钟后执行、第二次在30分钟后、第三次.....），直到最大超时重试次数后还得不到直充结果，订单状态会卡在支付成功状态，依赖T+1对账稽核流程保证最终一致性，订单状态根据对账结果流转为：已完成或待退款-->退款成功。\n\n#### 场景三：\n\n直充到账后的消息通知（APP消息推送或短信通知），采用最大努力通知型，这个业务场景比较简单，在直充成功后，订单状态流转为已完成，此时通过消息服务进行到账通知业务的解耦，调用消息服务失败的情况下，使用定时任务努力通知。\n\n#### 场景四：\n\n**对账稽核：**\n\n按照支付账期每日进行T+1对账，对账原则：以支付交易记录为准，对流量中心订单记录+支付网关交易记录+省CRM充值记录三方比对，将某些中间状态的订单（例如：支付成功、待退款）核对后将订单状态流转完结（已完成、退款成功）。\n\n**结算稽核：**\n\n对账成功后的数据定期进入结算流程，对支付网关周期内的支付金额与结算数据的金额进行核对，稽核成功后进行财务结算流程，将钱结算给省公司，并提供结算明细给省公司，供省公司与直充成本记录进行复核。\n\n**Ps**：以下是流量中心的部分架构设计，总体原则方向：**微服务化**\n\n### 流量中心-架构设计\n\n![系统架构](http://7xtkrj.com1.z0.glb.clouddn.com/%E6%B5%81%E9%87%8F%E4%B8%AD%E5%BF%83%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png)\n\n架构设计思想：在系统初期设计时以及部分硬性环境约束下，我们根据业务拆分为多个子系统（微服务）：商品服务、订单服务、库存服务、支付网关、统一接口平台、对账服务、结算服务、网关对接服务等，后续还会增加：账户服务、虚拟货币服务、卡券服务等等...。按照微服务的核心设计思想，所有服务完全独立、隔离，因此所有服务从上至下：请求接入（连接管理）、请求处理（计算服务）、数据存储（存储服务）进行拆分，接入与计算尽最大可能实现无状态，数据存储进行垂直+水平拆分，垂直拆分：商品库-mysql（读多写少，主从架构+读写分离）+redis（读多写少，集群方式）、订单库-mysql（读写均衡，多主多从+水平拆分）、库存专用库-redis（分布式+主备容灾）、外部交易系统-支付网关、外部办理系统-统一接口平台。\n\nPs：此架构目前已支撑总交易额3.6亿，总订单4680万，日均交易额500万，日订单量50万，后续业务量持续增加的情况下按照微服务思想继续拆分，例如将订单服务再拆分为：下单服务、查单服务，直到根据业务需求与系统关系耦合性拆分到最细粒度为止。\n\n1. 性能扩展：应用层计算服务（无状态应用）通过增加服务节点同比提升运算性能，配套质量（性能）监控服务dubbo monitor及整合Netflix的Hystrix熔断器对业务质量进行管理实现应用层的动态扩缩容。\n2. 容量扩展：数据层存储服务（有状态应用）通过对数据水平拆分实现容量的无限扩容，Nosql类方案：Codis中间件；关系型数据库：Mycat数据库分库分表中间件。目前项目中采用twitter的snowflake唯一ID生成器（根据业务场景优化后）自己实现数据的水平拆分和路由规则。\n3. 存储性能：Nosql：针对读多写少场景-使用淘宝的Tedis（多写随机读的特性提高性能），读写均衡使用-Codis；Mysql：读多写少场景使用一主多从架构（例如商品信息），读写均衡场景使用多主多从架构（例如订单信息）。\n\n整体拆分原则如下图：\n\n![拆分原则](http://7xtkrj.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99.png)\n\n***Never Give Up!***\n\n","tags":["architecture"]},{"title":"JVM调优","url":"/2018/09/12/jvm-optimize/","content":"\n> 先来一张JVM思维导图，网上看到的，整理的已经比较全面了，感觉很不错！\n\n1. Heap-堆：新生代（Eden-幸存区、S0-From、S1-To），老年代\n2. PermGen-持久代\n3. 线程栈\n\n<!--more-->\n\n![JVM导图](http://7xtkrj.com1.z0.glb.clouddn.com/JVM导图.jpg)\n\n> 类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程，如下图：\n\n![类加载过程](http://7xtkrj.com1.z0.glb.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png)\n\n1. 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象；\n2. 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用；\n3. 初始化，为类的静态变量赋予正确的初始值；\n4. 使用，new出对象程序中使用；\n5. 卸载，执行垃圾回收；\n\n> JVM的内存结构如下图：\n\n![JVM内存结构](http://7xtkrj.com1.z0.glb.clouddn.com/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png)\n\n- **Java堆（Heap）**，是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n- **方法区（Method Area）**，方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n- **程序计数器（Program Counter Register）**，程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。\n- **JVM栈（JVM Stacks）**，与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n- **本地方法栈（Native Method Stacks）**，本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n> 对象分配规则：\n\n- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。\n- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。\n- 长期存活的对象进入老年代，虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。\n- 动态判断对象的年龄，如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。\n- 空间分配担保，每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。\n\n> GC算法 垃圾回收：\n\n### 对象存活判断\n\n判断对象是否存活一般有两种方式：\n1. 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。\n2. 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。\n\n### GC算法\n\nGC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法：\n1. 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n2. 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n3. 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n4. 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n\n### 垃圾回收器\n\n1. Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。\n2. ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。\n3. Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。\n4. Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。\n5. CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\n6. G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。\n\n> GC分析 命令调优\n\n### GC日志分析\n\n年轻代young gc回收：\n\n```\n2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs] \n```\n\n老年代full gc回收：\n\n```\n2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]\n```\n\n通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化，ParOldGen表示gc回收前后老年代的内存变化，PSPermGen表示gc回收前后永久区的内存变化，young gc 主要是针对年轻代进行内存回收比较频繁，耗时短，full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数。\n\n- Young GC\n![Young GC](http://7xtkrj.com1.z0.glb.clouddn.com/young%20gc.png)\n- Full GC\n![Full GC](http://7xtkrj.com1.z0.glb.clouddn.com/full%20gc.png)\n\n### JVM操作命令\n\nSun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo\n\n- jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。\n- jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n- jmap，JVM Memory Map命令用于生成heap dump文件。\n- jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。\n- jstack，用于生成java虚拟机当前时刻的线程快照。\n- jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。\n\n### 调优工具\n\n常用调优工具分为两类，jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。\n\n- jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控。\n- jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。\n- MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。\n- GChisto，一款专业分析gc日志的工具。\n\n\n***Never Give Up!***\n\n","tags":["architecture"]},{"title":"Javassist动态编程","url":"/2018/09/10/javassist/","content":"> Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态\"AOP\"框架。\n\n<!--more-->\n\n### 项目地址\nhttps://github.com/jboss-javassist/javassist\n\nhttp://jboss-javassist.github.io/javassist\n\n### Javassist动态编程\n\n要想将编译时不存在的类在运行时动态创建并加载，通常有两种策略：\n1. 动态编译\n2. 动态生成二进制字节码（.class）\n\n对于第二种策略，实际上已经有诸多比较成熟的开源项目提供支持，如CGLib、ASM、Javassist等。这些开源项目通常都具备两方面的功能：\n1. 动态创建新类或新接口的二进制字节码\n2. 动态扩展现有类或接口的二进制字节码\n\n我们常用到的动态特性主要是反射，在运行时查找对象属性、方法，修改作用域，通过方法名称调用方法等。在线的应用不会频繁使用反射，因为反射的性能开销较大。其实还有一种和反射一样强大的特性，但是开销却很低，它就是Javassit。\n\nJavassit其实就是一个二方包，提供了运行时操作Java字节码的方法。大家都知道，Java代码编译完会生成.class文件，就是一堆字节码。JVM(准确说是JIT)会解释执行这些字节码(转换为机器码并执行)，由于字节码的解释执行是在运行时进行的，那我们能否手工编写字节码，再由JVM执行呢？答案是肯定的，而Javassist就提供了一些方便的方法，让我们通过这些方法生成字节码。\n\n类似字节码操作方法还有ASM。几种动态编程方法相比较，在性能上Javassist高于反射，但低于ASM，因为Javassist增加了一层抽象。在实现成本上Javassist和反射都很低，而ASM由于直接操作字节码，相比Javassist源码级别的api实现成本高很多。几个方法有自己的应用场景，比如Kryo使用的是ASM，追求性能的最大化。而NBeanCopyUtil采用的是Javassist，在对象拷贝的性能上也已经明显高于其他的库，并保持高易用性。实际项目中推荐先用Javassist实现原型，若在性能测试中发现Javassist成为了性能瓶颈，再考虑使用其他字节码操作方法做优化。\n\n总结：CGLib的底层基于ASM实现，是一个高效高性能的生成库；而ASM是一个轻量级的类库，但需要涉及到JVM的操作和指令；相比而言，Javassist要简单的多，完全是基于Java的API，但其性能相比前二者要差一些。在性能要求相对低的场合，Javassist仍然十分有用，如JBoss中就调用了Javassist。\n\n如下的代码是动态创建Java类二进制字节码并通过反射调用的示例，可供参考：\n\n```java\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtField;\nimport javassist.CtNewMethod;\nimport javassist.Modifier;\nimport javassist.NotFoundException;\nimport javassist.CtField.Initializer;\n\npublic class JavassistGenerator {\n\t\n\tpublic static void main(String[] args) throws CannotCompileException, NotFoundException, InstantiationException, IllegalAccessException, ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {\n\t\t// 创建类\n\t\tClassPool pool = ClassPool.getDefault();\n\t\tCtClass cls = pool.makeClass(\"cn.ibm.com.TestClass\");\n\t\t\n\t\t// 添加私有成员name及其getter、setter方法\n\t\tCtField param = new CtField(pool.get(\"java.lang.String\"), \"name\", cls);\n\t\tparam.setModifiers(Modifier.PRIVATE);\n\t\tcls.addMethod(CtNewMethod.setter(\"setName\", param));\n\t\tcls.addMethod(CtNewMethod.getter(\"getName\", param));\n\t\tcls.addField(param, Initializer.constant(\"\"));\n\t\t\n\t\t// 添加无参的构造体\n\t\tCtConstructor cons = new CtConstructor(new CtClass[] {}, cls);\n\t\tcons.setBody(\"{name = \\\"Brant\\\";}\");\n\t\tcls.addConstructor(cons);\n\t\t\n\t\t// 添加有参的构造体\n\t\tcons = new CtConstructor(new CtClass[] {pool.get(\"java.lang.String\")}, cls);\n\t\tcons.setBody(\"{$0.name = $1;}\");\n\t\tcls.addConstructor(cons);\n\t\t\n\t\t// 打印创建类的类名\n\t\tSystem.out.println(cls.toClass());\n\t\t\n\t\t// 通过反射创建无参的实例，并调用getName方法\n\t\tObject o = Class.forName(\"cn.ibm.com.TestClass\").newInstance();\n\t\tMethod getter = o.getClass().getMethod(\"getName\");\n\t\tSystem.out.println(getter.invoke(o));\n\t\t\n\t\t// 调用其setName方法\n\t\tMethod setter = o.getClass().getMethod(\"setName\", new Class[] {String.class});\n\t\tsetter.invoke(o, \"Adam\");\n\t\tSystem.out.println(getter.invoke(o));\n\t\t\n\t\t// 通过反射创建有参的实例，并调用getName方法\n\t\to = Class.forName(\"cn.ibm.com.TestClass\").getConstructor(String.class).newInstance(\"Liu Jian\");\n\t\tgetter = o.getClass().getMethod(\"getName\");\n\t\tSystem.out.println(getter.invoke(o));\n\t}\n\n}\n```\n\n### 特别注意：\n1. Javassist不支持要创建或注入的类中存在泛型参数\n2. Javassist对@类型的注解（Annotation）只支持查询，不支持添加或修改\n\n参考：\n\n- Javassist学习总结\nhttp://blog.csdn.net/sadfishsc/article/details/9999169\n\n- javassist学习\nhttp://yonglin4605.iteye.com/blog/1396494\n\n- Java动态编程初探——Javassist\nhttp://www.cnblogs.com/hucn/p/3636912.html\n\n---\n## 重点来了\n### Dubbo为什么使用Javassist替代反射\n以下内容摘自Dubbo官网：\n> Dubbo框架中使用到Javassist ProxyFactory Stable通过字节码生成代替反射，性能比较好（推荐使用）\t依赖于javassist.jar包，占用JVM的Perm内存，Perm可能要设大一些：java -XX:PermSize=128m\t可用于生产环境\tAlibaba\n\n直接上Dubbo核心领域（Proxy）代码，看看怎么使用Javassist的：\n```java\n/**\n核心领域中的代理实现类：com.alibaba.dubbo.common.bytecode.Proxy\n通过它实例化服务提供者的接口实现类，也就是具体业务逻辑方法；\n不过别着急，这里还没有出现Javassist的影子，注意看其中的：\ncom.alibaba.dubbo.common.bytecode.ClassGenerator\n这个是阿里自己根据需要又在Javassist上面封装的一个工具类，直接共Proxy类使用\n后面贴上ClassGenerator的部分核心代码，里面有直接调用Javassist动态创建类；\n\n*/\nlong id = PROXY_CLASS_COUNTER.getAndIncrement();\nString pkg = null;\nClassGenerator ccp = null, ccm = null;\ntry\n{\n\tccp = ClassGenerator.newInstance(cl);\n\n\tSet<String> worked = new HashSet<String>();\n\tList<Method> methods = new ArrayList<Method>();\n\n\tfor(int i=0;i<ics.length;i++)\n\t{\n\t\tif( !Modifier.isPublic(ics[i].getModifiers()) )\n\t\t{\n\t\t\tString npkg = ics[i].getPackage().getName();\n\t\t\tif( pkg == null )\n\t\t\t{\n\t\t\t\tpkg = npkg;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( !pkg.equals(npkg)  )\n\t\t\t\t\tthrow new IllegalArgumentException(\"non-public interfaces from different packages\");\n\t\t\t}\n\t\t}\n\t\tccp.addInterface(ics[i]);\n\n\t\tfor( Method method : ics[i].getMethods() )\n\t\t{\n\t\t\tString desc = ReflectUtils.getDesc(method);\n\t\t\tif( worked.contains(desc) )\n\t\t\t\tcontinue;\n\t\t\tworked.add(desc);\n\n\t\t\tint ix = methods.size();\n\t\t\tClass<?> rt = method.getReturnType();\n\t\t\tClass<?>[] pts = method.getParameterTypes();\n\n\t\t\tStringBuilder code = new StringBuilder(\"Object[] args = new Object[\").append(pts.length).append(\"];\");\n\t\t\tfor(int j=0;j<pts.length;j++)\n\t\t\t\tcode.append(\" args[\").append(j).append(\"] = ($w)$\").append(j+1).append(\";\");\n\t\t\tcode.append(\" Object ret = handler.invoke(this, methods[\" + ix + \"], args);\");\n\t\t\tif( !Void.TYPE.equals(rt) )\n\t\t\t\tcode.append(\" return \").append(asArgument(rt, \"ret\")).append(\";\");\n\n\t\t\tmethods.add(method);\n\t\t\tccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n\t\t}\n\t}\n\n\tif( pkg == null )\n\t\tpkg = PACKAGE_NAME;\n\n\t// create ProxyInstance class.\n\tString pcn = pkg + \".proxy\" + id;\n\tccp.setClassName(pcn);\n\tccp.addField(\"public static java.lang.reflect.Method[] methods;\");\n\tccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\n\tccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{ InvocationHandler.class }, new Class<?>[0], \"handler=$1;\");\n    ccp.addDefaultConstructor();\n\tClass<?> clazz = ccp.toClass();\n\tclazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n\n\t// create Proxy class.\n\tString fcn = Proxy.class.getName() + id;\n\tccm = ClassGenerator.newInstance(cl);\n\tccm.setClassName(fcn);\n\tccm.addDefaultConstructor();\n\tccm.setSuperClass(Proxy.class);\n\tccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\n\tClass<?> pc = ccm.toClass();\n\tproxy = (Proxy)pc.newInstance();\n}\n```\ncom.alibaba.dubbo.common.bytecode.ClassGenerator类的核心方法如下：\n```java\npublic Class<?> toClass(ClassLoader loader, ProtectionDomain pd)\n{\n\tif( mCtc != null )\n\t\tmCtc.detach();\n\tlong id = CLASS_NAME_COUNTER.getAndIncrement();\n\ttry\n\t{\n\t\tCtClass ctcs = mSuperClass == null ? null : mPool.get(mSuperClass);\n\t\tif( mClassName == null )\n\t\t\tmClassName = ( mSuperClass == null || javassist.Modifier.isPublic(ctcs.getModifiers())\n\t\t\t\t\t? ClassGenerator.class.getName() : mSuperClass + \"$sc\" ) + id;\n\t\tmCtc = mPool.makeClass(mClassName);\n\t\tif( mSuperClass != null )\n\t\t\tmCtc.setSuperclass(ctcs);\n\t\tmCtc.addInterface(mPool.get(DC.class.getName())); // add dynamic class tag.\n\t\tif( mInterfaces != null )\n\t\t\tfor( String cl : mInterfaces ) mCtc.addInterface(mPool.get(cl));\n\t\tif( mFields != null )\n\t\t\tfor( String code : mFields ) mCtc.addField(CtField.make(code, mCtc));\n\t\tif( mMethods != null )\n\t\t{\n\t\t\tfor( String code : mMethods )\n\t\t\t{\n\t\t\t\tif( code.charAt(0) == ':' )\n\t\t\t\t\tmCtc.addMethod(CtNewMethod.copy(getCtMethod(mCopyMethods.get(code.substring(1))), code.substring(1, code.indexOf('(')), mCtc, null));\n\t\t\t\telse\n\t\t\t\t\tmCtc.addMethod(CtNewMethod.make(code, mCtc));\n\t\t\t}\n\t\t}\n\t\tif( mDefaultConstructor )\n\t\t\tmCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));\n\t\tif( mConstructors != null )\n\t\t{\n\t\t\tfor( String code : mConstructors )\n\t\t\t{\n\t\t\t\tif( code.charAt(0) == ':' )\n\t\t\t\t{\n\t\t\t\t\tmCtc.addConstructor(CtNewConstructor.copy(getCtConstructor(mCopyConstructors.get(code.substring(1))), mCtc, null));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tString[] sn = mCtc.getSimpleName().split(\"\\\\$+\"); // inner class name include $.\n\t\t\t\t\tmCtc.addConstructor(CtNewConstructor.make(code.replaceFirst(SIMPLE_NAME_TAG, sn[sn.length-1]), mCtc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mCtc.toClass(loader, pd);\n\t}\n\tcatch(RuntimeException e)\n\t{\n\t\tthrow e;\n\t}\n\tcatch(NotFoundException e)\n\t{\n\t\tthrow new RuntimeException(e.getMessage(), e);\n\t}\n\tcatch(CannotCompileException e)\n\t{\n\t\tthrow new RuntimeException(e.getMessage(), e);\n\t}\n}\n```\n为什么Dubbo使用Javassist动态创建类而不适用反射呢？请看Proxy类中的如下代码：\n```java\nprivate static final Map<ClassLoader, Map<String, Object>> ProxyCacheMap = new WeakHashMap<ClassLoader, Map<String, Object>>();\n\n// 这里省略部分代码......\n\n//核心在这里↓↓↓\n// get cache by class loader.\nMap<String, Object> cache;\nsynchronized( ProxyCacheMap )\n{\n\tcache = ProxyCacheMap.get(cl);\n\tif( cache == null )\n    {\n\t\tcache = new HashMap<String, Object>();\n\t\tProxyCacheMap.put(cl, cache);\n    }\n}\n\nProxy proxy = null;\nsynchronized( cache )\n{\n\tdo\n\t{\n\t\tObject value = cache.get(key);\n\t\tif( value instanceof Reference<?> )\n\t\t{\n\t\t\tproxy = (Proxy)((Reference<?>)value).get();\n\t\t\tif( proxy != null )\n\t\t\t\treturn proxy;\n\t\t}\n\n\t\tif( value == PendingGenerationMarker )\n\t\t{\n\t\t\ttry{ cache.wait(); }catch(InterruptedException e){}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcache.put(key, PendingGenerationMarker);\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile( true );\n}\n\nlong id = PROXY_CLASS_COUNTER.getAndIncrement();\n\n```\n> 总结：Dubbo使用Javassist来代替反射很巧妙的使用了Javassist动态通过字节码在消费者中创建了类并实例化，然后放入jvm内存中缓存起来，也就是ProxyCacheMap对象中，在第一次使用的时候通过Javassist动态创建然后放入缓存中，后续就直接从缓存中拿来用了，so~~~除了第一次慢，再使用当然快了，对于这个设计膜拜了！这才符合阿里的特点啊！\n\n\n***Never Give Up!***\n\n","tags":["architecture"]},{"title":"Dubbo架构分析","url":"/2018/09/09/dubbo-architecture/","content":"> Dubbo是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。\n\n<!--more-->\n\n## 整体架构\n\nDubbo整体设计如下图所示：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png)\n\nDubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\n下面，结合Dubbo官方文档，我们分别理解一下框架分层架构中，各个层次的设计要点：\n1. 业务逻辑\n- 服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。\n2. RPC模块\n- 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。\n- 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。\n- 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。\n- 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。\n- 监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。\n- 协议定义层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。**Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它**，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。\n3. 远程调用协议\n- 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。\n- 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。\n- 数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。\n\n从上图可以看出，Dubbo对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。\n根据官方提供的，对于上述各层之间关系的描述，如下所示：\n1. 在RPC中，Protocol是核心层，也就是只要有Protocol + Invoker + Exporter就可以完成非透明的RPC调用，然后在Invoker的主过程上Filter拦截点。\n2. 图中的Consumer和Provider是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用Client和Server的原因是Dubbo在很多场景下都使用Provider、Consumer、Registry、Monitor划分逻辑拓普节点，保持统一概念。\n3. Cluster是外围概念，所以Cluster的目的是将多个Invoker伪装成一个Invoker，这样其它人只要关注Protocol层Invoker即可，加上Cluster或者去掉Cluster对其它层都不会造成影响，因为只有一个提供者时，是不需要Cluster的。\n4. Proxy层封装了所有接口的透明化代理，而在其它层都以Invoker为中心，只有到了暴露给用户使用时，才用Proxy将Invoker转成接口，或将接口实现转成Invoker，也就是去掉Proxy层RPC是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。\n5. Remoting实现是Dubbo协议的实现，如果你选择RMI协议，整个Remoting都不会用上，Remoting内部再划为Transport传输层和Exchange信息交换层，Transport层只负责单向消息传输，是对Mina、Netty、Grizzly的抽象，它也可以扩展UDP传输，而Exchange层是在传输层之上封装了Request-Response语义。\n6. Registry和Monitor实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。\n\n## 核心要点\n\n从上面的架构图中，我们可以了解到，Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：\n\n### 服务定义\n\n服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。\n\n### 服务注册\n\n对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择：\n- Multicast注册中心\n- Zookeeper注册中心（优选）\n- Redis注册中心\n- Simple注册中心\n\n### 服务监控\n\n无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。\n\n### 远程通信与信息交换\n\n远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个：\n- Mina\n- Netty（优选）\n- Grizzly\n\n### 服务调用\n\n基于RPC层，服务提供方和服务消费方之间的调用关系，如图所示：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8.jpg)\n\n上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。上述图所描述的调用流程如下：\n1. 服务提供方发布服务到服务注册中心；\n2. 服务消费方从服务注册中心订阅服务；\n3. 服务消费方调用已经注册的可用服务；\n\n接着，将上面抽象的调用流程图展开，详细如图所示：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/dubbo%E8%B0%83%E7%94%A8%E9%93%BE.jpg)\n\n### 注册/注销服务\n\n服务的注册与注销，是对服务提供方角色而言，那么注册服务与注销服务的时序图，如图所示：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B.jpg)\n\n### 服务订阅/取消\n\n为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。下面看一下对应的时序图，如图所示：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/dubbo%E6%B6%88%E8%B4%B9%E6%9C%8D%E5%8A%A1.jpg)\n\n### 协议支持\n\nDubbo支持多种协议，如下所示：\n- Dubbo协议\n- Hessian协议\n- HTTP协议\n- RMI协议\n- WebService协议\n- Thrift协议\n- Memcached协议\n- Redis协议\n\n在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。\n\n### Dubbo模块图\n\nDubbo以包结构来组织各个模块，各个模块及其关系，如图所示：\n\n![image](http://7xtkrj.com1.z0.glb.clouddn.com/dubbo%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86.png)\n\n可以通过Dubbo的代码（使用Maven管理）组织，与上面的模块进行比较。简单说明各个包的情况：\n- dubbo-common 公共逻辑模块，包括Util类和通用模型。\n- dubbo-remoting 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。\n- dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\n- dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\n- dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。\n- dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。\n- dubbo-config 配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。\n- dubbo-container 容器模块，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。","tags":["architecture"]}]